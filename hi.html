<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>3D 로켓 시뮬레이션 - 1m 단위 축 표시</title>
<style>
  body { margin: 0; overflow: hidden; background: #eef7ff; }
  #controls {
    position: fixed; top: 10px; left: 10px; background: white; padding: 10px; border-radius: 6px;
    font-family: Arial, sans-serif;
    z-index: 10;
    max-width: 280px;
  }
  label { display: block; margin-bottom: 6px; }
  input[type=number] { width: 70px; margin-left: 8px; }
  button { margin-top: 10px; padding: 5px 10px; }
  #stats {
    margin-top: 10px;
  }
</style>
</head>
<body>

<div id="controls">
  <label>초기 속도 (m/s): <input type="number" id="speed" value="30" min="0" max="100" step="1" /></label>
  <label>발사 각도 (도, XY 평면에서): <input type="number" id="angleXY" value="45" min="0" max="90" step="1" /></label>
  <label>발사 각도 (도, 수평면 회전 Z축): <input type="number" id="angleZ" value="0" min="-180" max="180" step="1" /></label>
  <label>질량 (kg): <input type="number" id="mass" value="0.1" min="0.01" max="10" step="0.01" /></label>
  <label>단면적 (m²): <input type="number" id="area" value="0.01" min="0.001" max="1" step="0.001" /></label>
  <label>풍속 (m/s): <input type="number" id="windSpeed" value="0" step="0.1" /></label>
  <label>풍향 (도): <input type="number" id="windDir" value="0" step="1" min="0" max="360" /></label>
  <div id="windButtons">
    <button data-angle="180">서풍</button>
    <button data-angle="0">동풍</button>
    <button data-angle="270">북풍</button>
    <button data-angle="90">남풍</button>
    <button data-angle="315">북서풍</button>
    <button data-angle="135">남동풍</button>
    <button data-angle="225">북동풍</button>
    <button data-angle="45">남서풍</button>
  </div>
  <button id="launchBtn">발사</button>
  <div id="stats">
    <div>최고 높이: <span id="maxHeight">0</span> m</div>
    <div>최종 거리: <span id="range">0</span> m</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

<script>
(() => {
  const {
    Scene, PerspectiveCamera, WebGLRenderer, Color, AmbientLight, DirectionalLight,
    Mesh, MeshPhongMaterial, CylinderGeometry, ConeGeometry, PlaneGeometry, AxesHelper,
    Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Line,
    Vector3, Quaternion, Sprite, SpriteMaterial, Texture, CanvasTexture
  } = THREE;

  const world = new CANNON.World();
  world.gravity.set(0, -9.8, 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 10;

  const scene = new Scene();
  scene.background = new Color(0xeef7ff);

  const camera = new PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 20, 40);

  const renderer = new WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new AmbientLight(0xffffff, 0.6));
  const directional = new DirectionalLight(0xffffff, 0.8);
  directional.position.set(20, 40, 20);
  scene.add(directional);

  scene.add(new AxesHelper(5));

  // 바닥 평면 (200x200)
  const floorGeo = new PlaneGeometry(400, 400);
  const floorMat = new MeshPhongMaterial({color: '#6c8'});
  const floorMesh = new Mesh(floorGeo, floorMat);
  floorMesh.rotation.x = -Math.PI/2;
  floorMesh.position.y = 0;
  scene.add(floorMesh);

  // 물리 바닥
  const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
  groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
  world.addBody(groundBody);

  // 1m 단위 축 표시용 그룹
  const axisGroup = new Group();
  scene.add(axisGroup);

  // 축 눈금과 숫자 표시 함수
  function createAxisMarks() {
    const markLength = 0.3;
    const fontSize = 32; // 캔버스 글자 크기

    // 재사용 가능한 캔버스 텍스쳐 생성 함수
    function createTextTexture(text) {
      const canvas = document.createElement('canvas');
      const size = 128;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.font = `${fontSize}px Arial`;
      ctx.fillStyle = 'black';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      ctx.clearRect(0, 0, size, size);
      ctx.fillText(text, size/2, size/2);
      return new CanvasTexture(canvas);
    }

    for(let i=0; i<=200; i++) {
      // X축 방향 눈금선 (Z=0선상, Y=0.01로 약간 띄워서 바닥과 겹치지 않게)
      {
        const geo = new BufferGeometry();
        const positions = new Float32Array([
          i, 0.01, 0,
          i, 0.01, markLength
        ]);
        geo.setAttribute('position', new Float32BufferAttribute(positions, 3));
        const line = new Line(geo, new LineBasicMaterial({color: 0x000000}));
        axisGroup.add(line);

        // 텍스트: i 숫자
        if(i % 10 === 0) { // 10m마다 숫자 표시
          const spriteMat = new SpriteMaterial({ map: createTextTexture(i.toString()), transparent:true });
          const sprite = new Sprite(spriteMat);
          sprite.scale.set(1.5, 0.75, 1);
          sprite.position.set(i, 0.01, markLength + 1);
          axisGroup.add(sprite);
        }
      }

      // Z축 방향 눈금선 (X=0선상, Y=0.01로 약간 띄움)
      {
        const geo = new BufferGeometry();
        const positions = new Float32Array([
          0, 0.01, i,
          markLength, 0.01, i
        ]);
        geo.setAttribute('position', new Float32BufferAttribute(positions, 3));
        const line = new Line(geo, new LineBasicMaterial({color: 0x000000}));
        axisGroup.add(line);

        // 텍스트: i 숫자 (10m마다)
        if(i % 10 === 0) {
          const spriteMat = new SpriteMaterial({ map: createTextTexture(i.toString()), transparent:true });
          const sprite = new Sprite(spriteMat);
          sprite.scale.set(1.5, 0.75, 1);
          sprite.position.set(markLength + 1, 0.01, i);
          axisGroup.add(sprite);
        }
      }
    }
  }

  createAxisMarks();

  let rocketBody = null;
  let rocketMesh = null;

  let firstTouchPosition = null;
  let touchedGround = false;

  const trajectoryMaxPoints = 200;
  let trajectoryPositions = new Float32Array(trajectoryMaxPoints * 3);
  let trajectoryIndex = 0;
  const trajectoryGeometry = new BufferGeometry();
  trajectoryGeometry.setAttribute('position', new Float32BufferAttribute(trajectoryPositions, 3));
  trajectoryGeometry.setDrawRange(0, 0);
  const trajectoryMaterial = new LineBasicMaterial({ color: 0x0000ff });
  const trajectoryLine = new Line(trajectoryGeometry, trajectoryMaterial);
  scene.add(trajectoryLine);

  const speedInput = document.getElementById('speed');
  const angleXYInput = document.getElementById('angleXY');
  const angleZInput = document.getElementById('angleZ');
  const massInput = document.getElementById('mass');
  const areaInput = document.getElementById('area');
  const launchBtn = document.getElementById('launchBtn');
  const maxHeightSpan = document.getElementById('maxHeight');
  const rangeSpan = document.getElementById('range');

  const Cd = 0.75;
  const rho = 1.225;

  let maxHeight = 0;
  let launched = false;
  let landed = false;
  let landTime = 0;
  let isMaxheight = false;

  const originPosition = new Vector3(0, 0.25, 0);

  function createRocket() {
    if (rocketBody) {
      world.removeBody(rocketBody);
      scene.remove(rocketMesh);
      rocketBody = null;
      rocketMesh = null;

      trajectoryGeometry.setDrawRange(0, 0);
      trajectoryIndex = 0;
      firstTouchPosition = null;
      touchedGround = false;
    }

    const mass = parseFloat(massInput.value);
    const area = parseFloat(areaInput.value);

    const bodyHeight = 1.0;
    const bodyRadius = 0.15;
    const coneHeight = 0.4;
    const coneRadius = bodyRadius;

    rocketBody = new CANNON.Body({
      mass: mass,
      linearDamping: 0,
      angularDamping: 0,
      type: CANNON.Body.DYNAMIC
    });

    rocketBody.inertia.set(0.01, 0.02, 0.01);
    rocketBody.invInertia.set(
      1/rocketBody.inertia.x,
      1/rocketBody.inertia.y,
      1/rocketBody.inertia.z
    );

    const cylinderShape = new CANNON.Cylinder(bodyRadius, bodyRadius, bodyHeight, 16);
    const quat = new CANNON.Quaternion();
    quat.setFromEuler(Math.PI / 2, 0, 0);
    rocketBody.addShape(cylinderShape, new CANNON.Vec3(0, bodyHeight/2, 0), quat);

    const sphereShape = new CANNON.Sphere(coneRadius);
    rocketBody.addShape(sphereShape, new CANNON.Vec3(0, bodyHeight + coneHeight/2, 0));

    rocketBody.position.copy(originPosition);
    rocketBody.velocity.set(0,0,0);
    rocketBody.angularVelocity.set(0,0,0);

    world.addBody(rocketBody);

    rocketMesh = new Group();

    const bodyGeometry = new CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16);
    const bodyMaterial = new MeshPhongMaterial({ color: 'red' });
    const bodyMesh = new Mesh(bodyGeometry, bodyMaterial);
    bodyMesh.position.y = bodyHeight / 2;
    rocketMesh.add(bodyMesh);

    const coneGeometry = new ConeGeometry(coneRadius, coneHeight, 16);
    const coneMaterial = new MeshPhongMaterial({ color: 'orange' });
    const coneMesh = new Mesh(coneGeometry, coneMaterial);
    coneMesh.position.y = bodyHeight + coneHeight / 2;
    rocketMesh.add(coneMesh);

    scene.add(rocketMesh);

    maxHeight = 0;
    maxHeightSpan.textContent = '0';
    rangeSpan.textContent = '0';
    launched = true;
    landed = false;
    landTime = 0;

    setRocketInitialDirection();

    const speed = parseFloat(speedInput.value);
    const angleXY = parseFloat(angleXYInput.value) * Math.PI/180;
    const angleZ = parseFloat(angleZInput.value) * Math.PI/180;

    const vx = speed * Math.cos(angleXY) * Math.cos(angleZ);
    const vy = speed * Math.sin(angleXY);
    const vz = speed * Math.cos(angleXY) * Math.sin(angleZ);

    rocketBody.velocity.set(vx, vy, vz);
  }

  function setRocketInitialDirection() {
    const angleXY = parseFloat(angleXYInput.value) * Math.PI/180;
    const angleZ = parseFloat(angleZInput.value) * Math.PI/180;

    const fromDir = new Vector3(0, 1, 0);
    const targetDir = new Vector3(
      Math.cos(angleXY) * Math.cos(angleZ),
      Math.sin(angleXY),
      Math.cos(angleXY) * Math.sin(angleZ)
    ).normalize();

    const quat = new Quaternion().setFromUnitVectors(fromDir, targetDir);

    if(rocketMesh) {
      rocketMesh.quaternion.copy(quat);
    }
  }

  function applyForces() {
    if (!rocketBody) return;

    const area = parseFloat(areaInput.value);
    const windSpeed = parseFloat(windSpeedInput.value);
    const windDirDeg = parseFloat(windDirInput.value);
    if (isNaN(windSpeed) || isNaN(windDirDeg)) return;

    const windDirRad = (windDirDeg + 180) * Math.PI / 180; // 반대 방향으로 적용
    const windVec = new CANNON.Vec3(
      windSpeed * Math.cos(windDirRad),
      0,
      windSpeed * Math.sin(windDirRad)
    );

    const relVel = rocketBody.velocity.vsub(windVec);
    const relSpeed = relVel.length();
    if (relSpeed === 0) return;

    const dragMag = 0.5 * Cd * rho * area * relSpeed * relSpeed;
    const drag = relVel.scale(-dragMag / relSpeed);

    const forcePos = new CANNON.Vec3(0, 0.6, 0);
    rocketBody.applyForce(drag, rocketBody.position.vadd(forcePos));
  }

  function updateRocketRotation() {
    if (!rocketBody) return;

    if (!landed) {
      const velocity = rocketBody.velocity;
      if (velocity.lengthSquared() < 0.0001) return;

      const dir = new Vector3(velocity.x, velocity.y, velocity.z).normalize();
      const fromDir = new Vector3(0, 1, 0);
      const targetQuat = new Quaternion().setFromUnitVectors(fromDir, dir);

      rocketMesh.quaternion.slerp(targetQuat, 0.1);
    }
  }

  function animate() {
    requestAnimationFrame(animate);

    if (rocketBody && launched) {
      if (!landed) {
        applyForces();
        world.step(1/60);

        rocketMesh.position.copy(rocketBody.position);
        updateRocketRotation();

        // 카메라 부드럽게 로켓 뒤쪽 위를 따라감
        const desiredCamPos = new Vector3(
          rocketBody.position.x + 10,
          rocketBody.position.y + 5,
          rocketBody.position.z + 10
        );
        camera.position.lerp(desiredCamPos, 0.05);
        camera.lookAt(rocketMesh.position);

        // 궤적 기록 및 그리기
        if (trajectoryIndex < trajectoryMaxPoints) {
          trajectoryPositions[trajectoryIndex * 3] = rocketBody.position.x;
          trajectoryPositions[trajectoryIndex * 3 + 1] = rocketBody.position.y;
          trajectoryPositions[trajectoryIndex * 3 + 2] = rocketBody.position.z;
          trajectoryIndex++;
          trajectoryGeometry.setDrawRange(1, trajectoryIndex);
        } else {
          for (let i = 0; i < (trajectoryMaxPoints - 1) * 3; i++) {
            trajectoryPositions[i] = trajectoryPositions[i + 3];
          }
          trajectoryPositions[(trajectoryMaxPoints -1)*3] = rocketBody.position.x;
          trajectoryPositions[(trajectoryMaxPoints -1)*3 +1] = rocketBody.position.y;
          trajectoryPositions[(trajectoryMaxPoints -1)*3 +2] = rocketBody.position.z;
        }
        trajectoryGeometry.attributes.position.needsUpdate = true;

        // 최고 높이 갱신
        if (rocketBody.position.y > maxHeight) {
          maxHeight = rocketBody.position.y;
          maxHeightSpan.textContent = maxHeight.toFixed(2);
        }

        else {
          isMaxheight = true;
        }

        // 땅 닿은 최초 위치 기록
        if (rocketBody.position.y <= 1 && !touchedGround && isMaxheight) {
          touchedGround = true;
          landed = true;
          firstTouchPosition = rocketBody.position.clone();
          console.log("landed")
        }

        // 착륙 감지: 땅(높이 0.2m) 닿으면 멈추고 고정
        if (rocketBody.position.y <= 1 && landed && launched && isMaxheight) {
          landTime = performance.now();

          rocketBody.velocity.set(0, 0, 0);
          rocketBody.angularVelocity.set(0, 0, 0);
          rocketBody.position.y = 1; // 착륙 고정 높이 0.2m
          console.log("finished")
          rocketBody.type = CANNON.Body.KINEMATIC;
          rocketBody.updateMassProperties();

          // 최초 착륙 위치 기준으로 거리 계산
          const dist = firstTouchPosition
            ? Math.sqrt(firstTouchPosition.x*firstTouchPosition.x + firstTouchPosition.z*firstTouchPosition.z)
            : 0;
          rangeSpan.textContent = dist.toFixed(2);
          return;
        }
        // - 
      } else {
        // 착륙 후 1초 지난 뒤 원점으로 복귀 시작
        const now = performance.now();
        if (now - landTime > 1000) {
          rocketMesh.position.lerp(originPosition, 0.05);
          rocketBody.position.copy(rocketMesh.position);

          // 카메라도 원점 뒤쪽 위 위치로 부드럽게 이동
          const desiredCamPos = new Vector3(
            rocketMesh.position.x + 10,
            rocketMesh.position.y + 5,
            rocketMesh.position.z + 10
          );
          camera.position.lerp(desiredCamPos, 0.05);
          camera.lookAt(rocketMesh.position);

          setRocketInitialDirection();

          if (rocketMesh.position.distanceTo(originPosition) < 0.1) {
            rocketBody.type = CANNON.Body.DYNAMIC;
            rocketBody.mass = parseFloat(massInput.value);
            rocketBody.updateMassProperties();

            launched = false;
            landed = true;
            isMaxheight = false;
            trajectoryGeometry.setDrawRange(0, 0);
            trajectoryIndex = 0;
            firstTouchPosition = null;
            touchedGround = false;
          }
        } else {
          // 착륙 후 1초 대기하는 동안 카메라 로켓 따라가게 유지
          const desiredCamPos = new Vector3(
            rocketBody.position.x + 10,
            rocketBody.position.y + 5,
            rocketBody.position.z + 10
          );
          camera.position.lerp(desiredCamPos, 0.05);
          camera.lookAt(rocketMesh.position);
        }
      }
    } else {
      // 발사 전 고정 카메라 위치
      camera.position.set(0, 20, 40);
      camera.lookAt(new Vector3(0, 0, 0));
    }

    renderer.render(scene, camera);
  }

  launchBtn.addEventListener('click', createRocket);

  angleXYInput.addEventListener('input', () => {
    if (!launched) setRocketInitialDirection();
  });
  angleZInput.addEventListener('input', () => {
    if (!launched) setRocketInitialDirection();
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();



  const windDirInput = document.getElementById('windDir');
  const windSpeedInput = document.getElementById('windSpeed');
  document.querySelectorAll('#windButtons button').forEach(btn => {
    btn.addEventListener('click', () => {
      windDirInput.value = btn.dataset.angle;
      windSpeedInput.value = 5;
    });
  });

})();
</script>

</body>
</html>